# Untitled notebook

```elixir
Mix.install([
  {:broadway, "~> 1.0"}
])
```

## Section

```elixir
defmodule Counter do
  use GenStage

  def init(_) do
    {:producer, 0}
  end

  def handle_demand(demand, counter) when demand > 0 do
    events = Enum.to_list(counter..(counter + demand - 1))
    {:noreply, [counter + 1], counter + demand}
  end
end
```

```elixir
defmodule CounterMessageTransformer do
  def transform(event, opts),
    do: %Broadway.Message{
      data: {event, DateTime.to_time(DateTime.utc_now())},
      acknowledger: {__MODULE__, :ack_id, event}
    }

  def ack(_ref, successes, _failures), do: successes |> IO.inspect()
end
```

```elixir
defmodule Processor do
  use GenStage

  def init(:hello) do
    {:producer_consumer, :state}
  end

  def process(message, state) do
    IO.inspect([message, state], label: "Processor")
  end
end
```

```elixir
defmodule MyBroadway do
  use Broadway

  def start_link(_opts) do
    Broadway.start_link(__MODULE__,
      name: __MODULE__,
      producer: [
        module: {Counter, []},
        transformer: {CounterMessageTransformer, :transform, [:hello]},
        rate_limiting: [
          allowed_messages: 1,
          interval: 1_000
        ]
      ],
      processors: [[default: [moduleconcurrency: 1, max_demand: 1]]]
    )
  end

  def handle_message(_proc, msg, _ctx) do
    IO.inspect(msg.data)
    %Broadway.Message{msg | data: :hello}
  end
end
```

```elixir
{:ok, pid} = MyBroadway.start_link(:ok)
:timer.sleep(5000)
Process.exit(pid, :kill)
```
